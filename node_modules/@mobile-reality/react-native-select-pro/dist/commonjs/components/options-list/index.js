"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OptionsList = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _portal = require("@gorhom/portal");

var _portals = require("../../constants/portals");

var _styles = require("../../constants/styles");

var _noOptions = require("../no-options");

var _option = require("../option");

var _optionsListWrapper = require("../options-list-wrapper");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const OptionsList = _ref => {
  let {
    aboveSelectControl,
    flatListProps,
    onPressOption,
    selectedOption,
    animated,
    animationDuration,
    searchedOptions,
    searchValue,
    searchable,
    isOpened,
    onOutsidePress,
    multiSelection,
    openedPosition: {
      width,
      top,
      left
    },
    optionsData,
    optionSelectedStyle,
    optionStyle,
    optionTextStyle,
    noOptionsText,
    scrollToSelectedOption,
    onSelect,
    optionsListStyle,
    NoOptionsComponent,
    OptionComponent,
    selectedOptionIndex
  } = _ref;
  const selectedOptionTyped = selectedOption;
  const flatList = (0, _react.useCallback)(node => {
    if (node !== null) {
      const isScrollToSelectedOption = scrollToSelectedOption && selectedOptionIndex >= 0 && typeof selectedOptionIndex === 'number';

      if (isScrollToSelectedOption) {
        try {
          node.scrollToIndex({
            index: selectedOptionIndex,
            animated: false
          }); // eslint-disable-next-line no-empty
        } catch {}
      }
    }
  }, [scrollToSelectedOption, selectedOptionIndex, onPressOption]);
  const measuredRef = (0, _react.useCallback)(node => {
    if (node !== null) {
      const reactTag = (0, _reactNative.findNodeHandle)(node);

      if (reactTag) {
        _reactNative.AccessibilityInfo.setAccessibilityFocus(reactTag);
      }
    }
  }, [isOpened]);

  const resolveData = () => {
    if (!searchable) {
      return optionsData;
    }

    if (searchable && searchValue.length === 0) {
      return optionsData;
    }

    if (selectedOptionTyped && (searchValue === null || searchValue === void 0 ? void 0 : searchValue.length) > 0 && searchValue === selectedOptionTyped.label) {
      return optionsData;
    }

    return searchedOptions;
  };

  const resolveIsSelected = item => {
    if (!multiSelection) {
      return item.value === (selectedOptionTyped === null || selectedOptionTyped === void 0 ? void 0 : selectedOptionTyped.value);
    }

    return selectedOption && selectedOption.find(option => item.value === option.value);
  };

  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, isOpened && /*#__PURE__*/_react.default.createElement(_portal.Portal, {
    hostName: _portals.Portals.SelectOutsideWrapper
  }, /*#__PURE__*/_react.default.createElement(_reactNative.TouchableWithoutFeedback, {
    accessibilityLabel: "Close a dropdown from outside",
    accessibilityRole: "button",
    onPress: onOutsidePress
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.modalOverlay
  }))), /*#__PURE__*/_react.default.createElement(_portal.Portal, {
    hostName: _portals.Portals.Select
  }, /*#__PURE__*/_react.default.createElement(_optionsListWrapper.OptionsListWrapper, {
    animated: animated,
    animationDuration: animationDuration,
    isOpened: isOpened,
    wrapperStyles: [styles.options, optionsListStyle, {
      top,
      left,
      width
    }, aboveSelectControl ? styles.overflown : styles.notOverflown]
  }, /*#__PURE__*/_react.default.createElement(_reactNative.FlatList, _extends({
    ref: flatList,
    accessibilityLabel: "Options list",
    accessibilityState: {
      expanded: isOpened
    },
    bounces: false,
    data: resolveData(),
    getItemLayout: (_data, index) => {
      var _StyleSheet$flatten;

      const height = (_StyleSheet$flatten = _reactNative.StyleSheet.flatten(optionStyle)) === null || _StyleSheet$flatten === void 0 ? void 0 : _StyleSheet$flatten.height;
      const isNumber = typeof height === 'number';
      return {
        length: isNumber ? height : _styles.ITEM_HEIGHT,
        offset: isNumber ? height * index : _styles.ITEM_HEIGHT * index,
        index
      };
    },
    keyExtractor: _ref2 => {
      let {
        value
      } = _ref2;
      return value;
    },
    keyboardShouldPersistTaps: "handled",
    persistentScrollbar: true,
    renderItem: _ref3 => {
      let {
        item,
        index
      } = _ref3;
      const {
        value
      } = item;
      const isSelected = !!resolveIsSelected(item);
      return /*#__PURE__*/_react.default.createElement(_option.Option, {
        key: value,
        ref: index === 0 ? measuredRef : undefined,
        OptionComponent: OptionComponent,
        isSelected: isSelected,
        option: item,
        optionSelectedStyle: optionSelectedStyle,
        optionStyle: optionStyle,
        optionTextStyle: optionTextStyle,
        optionIndex: index,
        onPressOption: onPressOption,
        onSelect: onSelect
      });
    }
  }, flatListProps, {
    ListEmptyComponent: NoOptionsComponent || /*#__PURE__*/_react.default.createElement(_noOptions.NoOptions, {
      noOptionsText: noOptionsText
    })
  })))));
};

exports.OptionsList = OptionsList;

const styles = _reactNative.StyleSheet.create({
  modalOverlay: { ..._reactNative.StyleSheet.absoluteFillObject,
    zIndex: 1
  },
  options: {
    flex: 1,
    position: 'absolute',
    zIndex: 1,
    backgroundColor: _styles.COLORS.WHITE,
    borderWidth: _styles.BORDER_WIDTH,
    maxHeight: _styles.MAX_HEIGHT_LIST,
    elevation: 5
  },
  notOverflown: {
    borderTopWidth: 0,
    borderBottomRightRadius: _styles.SHAPE,
    borderBottomLeftRadius: _styles.SHAPE
  },
  overflown: {
    borderBottomWidth: 0,
    borderTopRightRadius: _styles.SHAPE,
    borderTopLeftRadius: _styles.SHAPE
  }
});
//# sourceMappingURL=index.js.map