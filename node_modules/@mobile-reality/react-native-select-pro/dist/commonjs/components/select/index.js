"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Select = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _styles = require("../../constants/styles");

var _helpers = require("../../helpers");

var _reducer = require("../../state/reducer");

var _types = require("../../state/types");

var _optionsList = require("../options-list");

var _selectControl = require("../select-control");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const Select = /*#__PURE__*/(0, _react.forwardRef)((props, ref) => {
  const {
    // Required
    options,
    // Callbacks
    onSelect,
    onRemove,
    onDropdownOpened,
    onDropdownClosed,
    // Texts
    noOptionsText = 'No options',
    placeholderText = 'Select...',
    // Animations
    animated = false,
    animationDuration = _styles.ANIMATION_DURATION,
    // Behaviour
    clearable = true,
    closeDropdownOnSelect = true,
    disabled = false,
    scrollToSelectedOption = true,
    hideSelectControlArrow = false,
    // Additional features
    defaultOption,
    flatListProps,
    // Search
    searchable = false,
    searchPattern = payload => `(${payload})`,
    // Multiselect
    multiSelection = false,
    // Custom components
    NoOptionsComponent,
    OptionComponent,
    // Custom sources
    customLeftIconSource,
    // Colors
    placeholderTextColor = _styles.COLORS.GRAY,
    // Accessibility
    selectControlClearOptionA11yLabel,
    selectControlOpenDropdownA11yLabel,
    // Styles
    optionStyle,
    optionsListStyle,
    optionTextStyle,
    optionSelectedStyle,
    selectContainerStyle,
    selectControlArrowImageStyle,
    selectControlButtonsContainerStyle,
    selectControlClearOptionButtonStyle,
    selectControlClearOptionImageStyle,
    selectControlClearOptionButtonHitSlop,
    selectControlDisabledStyle,
    selectControlStyle,
    selectControlTextStyle,
    customLeftIconStyles,
    multiSelectionOptionStyle
  } = props;
  const [state, dispatch] = (0, _react.useReducer)(_reducer.reducer, _reducer.initialData);
  const {
    isOpened,
    selectedOption,
    optionsData,
    openedPosition,
    searchValue,
    searchedOptions,
    searchInputRef,
    selectedOptionIndex
  } = state;
  const {
    aboveSelectControl
  } = openedPosition;
  const selectedOptionTyped = selectedOption;
  const containerRef = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    if (!Array.isArray(options)) {
      // eslint-disable-next-line no-console
      console.error('You must pass array in the options prop');
      return;
    }

    if (options.length > 0) {
      dispatch({
        type: _types.Action.SetOptionsData,
        payload: options
      });
      const isValidPassDefaultOption = defaultOption && // eslint-disable-next-line no-prototype-builtins
      defaultOption.hasOwnProperty('value') && // eslint-disable-next-line no-prototype-builtins
      defaultOption.hasOwnProperty('label');

      if (isValidPassDefaultOption) {
        const foundIndex = options.findIndex(_ref => {
          let {
            value
          } = _ref;
          return value === defaultOption.value;
        });
        dispatch({
          type: _types.Action.SelectOption,
          payload: {
            selectedOption: defaultOption,
            selectedOptionIndex: foundIndex
          }
        });
      }
    }
  }, [options]);
  (0, _react.useImperativeHandle)(ref, () => ({
    clear: () => {
      dispatch({
        type: _types.Action.SelectOption,
        payload: {
          selectedOption: null,
          selectedOptionIndex: -1
        }
      });
      dispatch({
        type: _types.Action.SetOptionsData,
        payload: options
      });

      if (onRemove) {
        onRemove(selectedOption, selectedOptionIndex);
      }
    },
    open: () => {
      if (containerRef.current && !disabled) {
        dispatch({
          type: _types.Action.Open
        });
        setPosition();
      }
    },
    close: () => {
      dispatch({
        type: _types.Action.Close
      });
    },
    getState: () => state
  }));

  const hideKeyboardIfNeeded = () => {
    // TODO: Better condition handling, however, typo error appears in every combination
    if (searchInputRef && searchInputRef.current) {
      var _current;

      searchInputRef === null || searchInputRef === void 0 ? void 0 : (_current = searchInputRef.current) === null || _current === void 0 ? void 0 : _current.blur();
    }
  };

  const onPressOption = (option, optionIndex) => {
    if (closeDropdownOnSelect) {
      dispatch({
        type: _types.Action.Close
      });
    }

    const resolveOption = () => {
      if (!multiSelection) {
        return {
          selectedOption: option,
          selectedOptionIndex: optionIndex
        };
      }

      const selectedOptionAsArray = selectedOption;
      const foundSelectedOption = selectedOptionAsArray && selectedOptionAsArray.find(selectedOption => selectedOption.value === option.value);

      if (foundSelectedOption) {
        return {
          selectedOption: selectedOptionAsArray,
          selectedOptionIndex: typeof selectedOptionIndex === 'number' ? selectedOptionIndex : [...selectedOptionIndex]
        };
      }

      const sOption = selectedOptionAsArray ? selectedOptionAsArray.concat(option) : [option];
      const sOptionIndex = optionsData.map((item, index) => {
        if (sOption.some(_ref2 => {
          let {
            value
          } = _ref2;
          return value === item.value;
        })) {
          return index;
        }

        return undefined;
      }).filter(item => item !== undefined);
      return {
        selectedOption: sOption,
        selectedOptionIndex: sOptionIndex.length > 0 ? [...sOptionIndex] : -1
      };
    };

    dispatch({
      type: _types.Action.SelectOption,
      payload: {
        selectedOption: resolveOption().selectedOption,
        selectedOptionIndex: resolveOption().selectedOptionIndex
      }
    });

    if (searchable) {
      if (multiSelection) {
        dispatch({
          type: _types.Action.SetSearchValue,
          payload: ''
        });
      } else {
        dispatch({
          type: _types.Action.SetSearchValue,
          payload: option.label
        });
      }
    }

    dispatch({
      type: _types.Action.SetOptionsData,
      payload: options
    });

    if (option) {
      hideKeyboardIfNeeded();
    }
  };

  const windowDimensions = (0, _reactNative.useWindowDimensions)();

  const setPosition = () => {
    if (containerRef.current) {
      containerRef.current.measure((_x, _y, width, height, pageX, pageY) => {
        var _StyleSheet$flatten, _StyleSheet$flatten2;

        const listHeightFromProp = (_StyleSheet$flatten = _reactNative.StyleSheet.flatten(optionsListStyle)) === null || _StyleSheet$flatten === void 0 ? void 0 : _StyleSheet$flatten.maxHeight;
        const optionHeightFromProp = (_StyleSheet$flatten2 = _reactNative.StyleSheet.flatten(optionStyle)) === null || _StyleSheet$flatten2 === void 0 ? void 0 : _StyleSheet$flatten2.height;
        const optionHeight = (0, _helpers.getSize)({
          size: optionHeightFromProp,
          sizeType: 'height',
          sizeFallback: _styles.ITEM_HEIGHT,
          screenSize: windowDimensions.height
        });
        const listHeight = (0, _helpers.getSize)({
          size: listHeightFromProp,
          sizeType: 'height',
          sizeFallback: _styles.MAX_HEIGHT_LIST,
          screenSize: windowDimensions.height
        });
        const finalHeight = listHeight >= optionsData.length * optionHeight ? optionsData.length * optionHeight : listHeight;
        const isOverflow = pageY + height + finalHeight > windowDimensions.height;
        dispatch({
          type: _types.Action.SetPosition,
          payload: {
            width,
            top: isOverflow ? pageY - finalHeight : pageY + height,
            left: _reactNative.I18nManager.isRTL ? windowDimensions.width - width - pageX : pageX,
            aboveSelectControl: isOverflow
          }
        });
      });
    }
  };

  const onPressSelectControl = () => {
    if (isOpened) {
      dispatch({
        type: _types.Action.Close
      });
      return;
    }

    setPosition();

    if (containerRef.current) {
      dispatch({
        type: _types.Action.Open
      });
    }
  };

  const onOutsidePress = () => {
    dispatch({
      type: _types.Action.Close
    });
    dispatch({
      type: _types.Action.SetOptionsData,
      payload: options
    });

    if (searchable && selectedOptionTyped !== null && selectedOptionTyped !== void 0 && selectedOptionTyped.label) {
      dispatch({
        type: _types.Action.SetSearchValue,
        payload: selectedOptionTyped.label
      });
    }

    hideKeyboardIfNeeded();
  };

  (0, _react.useEffect)(() => {
    if (isOpened) {
      onDropdownOpened === null || onDropdownOpened === void 0 ? void 0 : onDropdownOpened();
    } else {
      onDropdownClosed === null || onDropdownClosed === void 0 ? void 0 : onDropdownClosed();
    }
  }, [isOpened]);
  return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.relative, selectContainerStyle],
    onLayout: setPosition
  }, /*#__PURE__*/_react.default.createElement(_selectControl.SelectControl, {
    ref: containerRef,
    aboveSelectControl: aboveSelectControl,
    animated: animated,
    animationDuration: animationDuration,
    clearable: clearable,
    customLeftIconSource: customLeftIconSource,
    customLeftIconStyles: customLeftIconStyles,
    disabled: disabled,
    dispatch: dispatch,
    hideSelectControlArrow: hideSelectControlArrow,
    isOpened: isOpened,
    multiSelection: multiSelection,
    multiSelectionOptionStyle: multiSelectionOptionStyle,
    options: options,
    placeholderText: placeholderText,
    placeholderTextColor: placeholderTextColor,
    searchPattern: searchPattern,
    searchValue: searchValue,
    searchable: searchable,
    selectControlArrowImageStyle: selectControlArrowImageStyle,
    selectControlButtonsContainerStyle: selectControlButtonsContainerStyle,
    selectControlClearOptionA11yLabel: selectControlClearOptionA11yLabel,
    selectControlClearOptionButtonHitSlop: selectControlClearOptionButtonHitSlop,
    selectControlClearOptionButtonStyle: selectControlClearOptionButtonStyle,
    selectControlClearOptionImageStyle: selectControlClearOptionImageStyle,
    selectControlDisabledStyle: selectControlDisabledStyle,
    selectControlOpenDropdownA11yLabel: selectControlOpenDropdownA11yLabel,
    selectControlStyle: selectControlStyle,
    selectControlTextStyle: selectControlTextStyle,
    selectedOption: selectedOption,
    selectedOptionIndex: selectedOptionIndex,
    setPosition: setPosition,
    onPressSelectControl: onPressSelectControl,
    onSelect: onSelect,
    onRemove: onRemove
  }), /*#__PURE__*/_react.default.createElement(_optionsList.OptionsList, {
    NoOptionsComponent: NoOptionsComponent,
    OptionComponent: OptionComponent,
    aboveSelectControl: aboveSelectControl,
    animated: animated,
    animationDuration: animationDuration,
    flatListProps: flatListProps,
    isOpened: isOpened,
    multiSelection: multiSelection,
    noOptionsText: noOptionsText,
    openedPosition: openedPosition,
    optionSelectedStyle: optionSelectedStyle,
    optionStyle: optionStyle,
    optionTextStyle: optionTextStyle,
    optionsData: optionsData,
    optionsListStyle: optionsListStyle,
    scrollToSelectedOption: scrollToSelectedOption,
    searchValue: searchValue,
    searchable: searchable,
    searchedOptions: searchedOptions,
    selectedOption: selectedOption,
    selectedOptionIndex: selectedOptionIndex,
    onOutsidePress: onOutsidePress,
    onPressOption: onPressOption,
    onSelect: onSelect
  }));
});
exports.Select = Select;

const styles = _reactNative.StyleSheet.create({
  relative: {
    position: 'relative'
  }
});

Select.displayName = 'Select';
//# sourceMappingURL=index.js.map