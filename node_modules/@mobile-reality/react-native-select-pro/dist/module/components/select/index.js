import React, { forwardRef, useEffect, useImperativeHandle, useReducer, useRef } from 'react';
import { I18nManager, StyleSheet, useWindowDimensions, View } from 'react-native';
import { ANIMATION_DURATION, COLORS, ITEM_HEIGHT, MAX_HEIGHT_LIST } from '../../constants/styles';
import { getSize } from '../../helpers';
import { initialData, reducer } from '../../state/reducer';
import { Action } from '../../state/types';
import { OptionsList } from '../options-list';
import { SelectControl } from '../select-control';
export const Select = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    // Required
    options,
    // Callbacks
    onSelect,
    onRemove,
    onDropdownOpened,
    onDropdownClosed,
    // Texts
    noOptionsText = 'No options',
    placeholderText = 'Select...',
    // Animations
    animated = false,
    animationDuration = ANIMATION_DURATION,
    // Behaviour
    clearable = true,
    closeDropdownOnSelect = true,
    disabled = false,
    scrollToSelectedOption = true,
    hideSelectControlArrow = false,
    // Additional features
    defaultOption,
    flatListProps,
    // Search
    searchable = false,
    searchPattern = payload => `(${payload})`,
    // Multiselect
    multiSelection = false,
    // Custom components
    NoOptionsComponent,
    OptionComponent,
    // Custom sources
    customLeftIconSource,
    // Colors
    placeholderTextColor = COLORS.GRAY,
    // Accessibility
    selectControlClearOptionA11yLabel,
    selectControlOpenDropdownA11yLabel,
    // Styles
    optionStyle,
    optionsListStyle,
    optionTextStyle,
    optionSelectedStyle,
    selectContainerStyle,
    selectControlArrowImageStyle,
    selectControlButtonsContainerStyle,
    selectControlClearOptionButtonStyle,
    selectControlClearOptionImageStyle,
    selectControlClearOptionButtonHitSlop,
    selectControlDisabledStyle,
    selectControlStyle,
    selectControlTextStyle,
    customLeftIconStyles,
    multiSelectionOptionStyle
  } = props;
  const [state, dispatch] = useReducer(reducer, initialData);
  const {
    isOpened,
    selectedOption,
    optionsData,
    openedPosition,
    searchValue,
    searchedOptions,
    searchInputRef,
    selectedOptionIndex
  } = state;
  const {
    aboveSelectControl
  } = openedPosition;
  const selectedOptionTyped = selectedOption;
  const containerRef = useRef(null);
  useEffect(() => {
    if (!Array.isArray(options)) {
      // eslint-disable-next-line no-console
      console.error('You must pass array in the options prop');
      return;
    }

    if (options.length > 0) {
      dispatch({
        type: Action.SetOptionsData,
        payload: options
      });
      const isValidPassDefaultOption = defaultOption && // eslint-disable-next-line no-prototype-builtins
      defaultOption.hasOwnProperty('value') && // eslint-disable-next-line no-prototype-builtins
      defaultOption.hasOwnProperty('label');

      if (isValidPassDefaultOption) {
        const foundIndex = options.findIndex(_ref => {
          let {
            value
          } = _ref;
          return value === defaultOption.value;
        });
        dispatch({
          type: Action.SelectOption,
          payload: {
            selectedOption: defaultOption,
            selectedOptionIndex: foundIndex
          }
        });
      }
    }
  }, [options]);
  useImperativeHandle(ref, () => ({
    clear: () => {
      dispatch({
        type: Action.SelectOption,
        payload: {
          selectedOption: null,
          selectedOptionIndex: -1
        }
      });
      dispatch({
        type: Action.SetOptionsData,
        payload: options
      });

      if (onRemove) {
        onRemove(selectedOption, selectedOptionIndex);
      }
    },
    open: () => {
      if (containerRef.current && !disabled) {
        dispatch({
          type: Action.Open
        });
        setPosition();
      }
    },
    close: () => {
      dispatch({
        type: Action.Close
      });
    },
    getState: () => state
  }));

  const hideKeyboardIfNeeded = () => {
    // TODO: Better condition handling, however, typo error appears in every combination
    if (searchInputRef && searchInputRef.current) {
      var _current;

      searchInputRef === null || searchInputRef === void 0 ? void 0 : (_current = searchInputRef.current) === null || _current === void 0 ? void 0 : _current.blur();
    }
  };

  const onPressOption = (option, optionIndex) => {
    if (closeDropdownOnSelect) {
      dispatch({
        type: Action.Close
      });
    }

    const resolveOption = () => {
      if (!multiSelection) {
        return {
          selectedOption: option,
          selectedOptionIndex: optionIndex
        };
      }

      const selectedOptionAsArray = selectedOption;
      const foundSelectedOption = selectedOptionAsArray && selectedOptionAsArray.find(selectedOption => selectedOption.value === option.value);

      if (foundSelectedOption) {
        return {
          selectedOption: selectedOptionAsArray,
          selectedOptionIndex: typeof selectedOptionIndex === 'number' ? selectedOptionIndex : [...selectedOptionIndex]
        };
      }

      const sOption = selectedOptionAsArray ? selectedOptionAsArray.concat(option) : [option];
      const sOptionIndex = optionsData.map((item, index) => {
        if (sOption.some(_ref2 => {
          let {
            value
          } = _ref2;
          return value === item.value;
        })) {
          return index;
        }

        return undefined;
      }).filter(item => item !== undefined);
      return {
        selectedOption: sOption,
        selectedOptionIndex: sOptionIndex.length > 0 ? [...sOptionIndex] : -1
      };
    };

    dispatch({
      type: Action.SelectOption,
      payload: {
        selectedOption: resolveOption().selectedOption,
        selectedOptionIndex: resolveOption().selectedOptionIndex
      }
    });

    if (searchable) {
      if (multiSelection) {
        dispatch({
          type: Action.SetSearchValue,
          payload: ''
        });
      } else {
        dispatch({
          type: Action.SetSearchValue,
          payload: option.label
        });
      }
    }

    dispatch({
      type: Action.SetOptionsData,
      payload: options
    });

    if (option) {
      hideKeyboardIfNeeded();
    }
  };

  const windowDimensions = useWindowDimensions();

  const setPosition = () => {
    if (containerRef.current) {
      containerRef.current.measure((_x, _y, width, height, pageX, pageY) => {
        var _StyleSheet$flatten, _StyleSheet$flatten2;

        const listHeightFromProp = (_StyleSheet$flatten = StyleSheet.flatten(optionsListStyle)) === null || _StyleSheet$flatten === void 0 ? void 0 : _StyleSheet$flatten.maxHeight;
        const optionHeightFromProp = (_StyleSheet$flatten2 = StyleSheet.flatten(optionStyle)) === null || _StyleSheet$flatten2 === void 0 ? void 0 : _StyleSheet$flatten2.height;
        const optionHeight = getSize({
          size: optionHeightFromProp,
          sizeType: 'height',
          sizeFallback: ITEM_HEIGHT,
          screenSize: windowDimensions.height
        });
        const listHeight = getSize({
          size: listHeightFromProp,
          sizeType: 'height',
          sizeFallback: MAX_HEIGHT_LIST,
          screenSize: windowDimensions.height
        });
        const finalHeight = listHeight >= optionsData.length * optionHeight ? optionsData.length * optionHeight : listHeight;
        const isOverflow = pageY + height + finalHeight > windowDimensions.height;
        dispatch({
          type: Action.SetPosition,
          payload: {
            width,
            top: isOverflow ? pageY - finalHeight : pageY + height,
            left: I18nManager.isRTL ? windowDimensions.width - width - pageX : pageX,
            aboveSelectControl: isOverflow
          }
        });
      });
    }
  };

  const onPressSelectControl = () => {
    if (isOpened) {
      dispatch({
        type: Action.Close
      });
      return;
    }

    setPosition();

    if (containerRef.current) {
      dispatch({
        type: Action.Open
      });
    }
  };

  const onOutsidePress = () => {
    dispatch({
      type: Action.Close
    });
    dispatch({
      type: Action.SetOptionsData,
      payload: options
    });

    if (searchable && selectedOptionTyped !== null && selectedOptionTyped !== void 0 && selectedOptionTyped.label) {
      dispatch({
        type: Action.SetSearchValue,
        payload: selectedOptionTyped.label
      });
    }

    hideKeyboardIfNeeded();
  };

  useEffect(() => {
    if (isOpened) {
      onDropdownOpened === null || onDropdownOpened === void 0 ? void 0 : onDropdownOpened();
    } else {
      onDropdownClosed === null || onDropdownClosed === void 0 ? void 0 : onDropdownClosed();
    }
  }, [isOpened]);
  return /*#__PURE__*/React.createElement(View, {
    style: [styles.relative, selectContainerStyle],
    onLayout: setPosition
  }, /*#__PURE__*/React.createElement(SelectControl, {
    ref: containerRef,
    aboveSelectControl: aboveSelectControl,
    animated: animated,
    animationDuration: animationDuration,
    clearable: clearable,
    customLeftIconSource: customLeftIconSource,
    customLeftIconStyles: customLeftIconStyles,
    disabled: disabled,
    dispatch: dispatch,
    hideSelectControlArrow: hideSelectControlArrow,
    isOpened: isOpened,
    multiSelection: multiSelection,
    multiSelectionOptionStyle: multiSelectionOptionStyle,
    options: options,
    placeholderText: placeholderText,
    placeholderTextColor: placeholderTextColor,
    searchPattern: searchPattern,
    searchValue: searchValue,
    searchable: searchable,
    selectControlArrowImageStyle: selectControlArrowImageStyle,
    selectControlButtonsContainerStyle: selectControlButtonsContainerStyle,
    selectControlClearOptionA11yLabel: selectControlClearOptionA11yLabel,
    selectControlClearOptionButtonHitSlop: selectControlClearOptionButtonHitSlop,
    selectControlClearOptionButtonStyle: selectControlClearOptionButtonStyle,
    selectControlClearOptionImageStyle: selectControlClearOptionImageStyle,
    selectControlDisabledStyle: selectControlDisabledStyle,
    selectControlOpenDropdownA11yLabel: selectControlOpenDropdownA11yLabel,
    selectControlStyle: selectControlStyle,
    selectControlTextStyle: selectControlTextStyle,
    selectedOption: selectedOption,
    selectedOptionIndex: selectedOptionIndex,
    setPosition: setPosition,
    onPressSelectControl: onPressSelectControl,
    onSelect: onSelect,
    onRemove: onRemove
  }), /*#__PURE__*/React.createElement(OptionsList, {
    NoOptionsComponent: NoOptionsComponent,
    OptionComponent: OptionComponent,
    aboveSelectControl: aboveSelectControl,
    animated: animated,
    animationDuration: animationDuration,
    flatListProps: flatListProps,
    isOpened: isOpened,
    multiSelection: multiSelection,
    noOptionsText: noOptionsText,
    openedPosition: openedPosition,
    optionSelectedStyle: optionSelectedStyle,
    optionStyle: optionStyle,
    optionTextStyle: optionTextStyle,
    optionsData: optionsData,
    optionsListStyle: optionsListStyle,
    scrollToSelectedOption: scrollToSelectedOption,
    searchValue: searchValue,
    searchable: searchable,
    searchedOptions: searchedOptions,
    selectedOption: selectedOption,
    selectedOptionIndex: selectedOptionIndex,
    onOutsidePress: onOutsidePress,
    onPressOption: onPressOption,
    onSelect: onSelect
  }));
});
const styles = StyleSheet.create({
  relative: {
    position: 'relative'
  }
});
Select.displayName = 'Select';
//# sourceMappingURL=index.js.map