function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { useCallback } from 'react';
import { AccessibilityInfo, findNodeHandle, FlatList, StyleSheet, TouchableWithoutFeedback, View } from 'react-native';
import { Portal } from '@gorhom/portal';
import { Portals } from '../../constants/portals';
import { BORDER_WIDTH, COLORS, ITEM_HEIGHT, MAX_HEIGHT_LIST, SHAPE } from '../../constants/styles';
import { NoOptions } from '../no-options';
import { Option } from '../option';
import { OptionsListWrapper } from '../options-list-wrapper';
export const OptionsList = _ref => {
  let {
    aboveSelectControl,
    flatListProps,
    onPressOption,
    selectedOption,
    animated,
    animationDuration,
    searchedOptions,
    searchValue,
    searchable,
    isOpened,
    onOutsidePress,
    multiSelection,
    openedPosition: {
      width,
      top,
      left
    },
    optionsData,
    optionSelectedStyle,
    optionStyle,
    optionTextStyle,
    noOptionsText,
    scrollToSelectedOption,
    onSelect,
    optionsListStyle,
    NoOptionsComponent,
    OptionComponent,
    selectedOptionIndex
  } = _ref;
  const selectedOptionTyped = selectedOption;
  const flatList = useCallback(node => {
    if (node !== null) {
      const isScrollToSelectedOption = scrollToSelectedOption && selectedOptionIndex >= 0 && typeof selectedOptionIndex === 'number';

      if (isScrollToSelectedOption) {
        try {
          node.scrollToIndex({
            index: selectedOptionIndex,
            animated: false
          }); // eslint-disable-next-line no-empty
        } catch {}
      }
    }
  }, [scrollToSelectedOption, selectedOptionIndex, onPressOption]);
  const measuredRef = useCallback(node => {
    if (node !== null) {
      const reactTag = findNodeHandle(node);

      if (reactTag) {
        AccessibilityInfo.setAccessibilityFocus(reactTag);
      }
    }
  }, [isOpened]);

  const resolveData = () => {
    if (!searchable) {
      return optionsData;
    }

    if (searchable && searchValue.length === 0) {
      return optionsData;
    }

    if (selectedOptionTyped && (searchValue === null || searchValue === void 0 ? void 0 : searchValue.length) > 0 && searchValue === selectedOptionTyped.label) {
      return optionsData;
    }

    return searchedOptions;
  };

  const resolveIsSelected = item => {
    if (!multiSelection) {
      return item.value === (selectedOptionTyped === null || selectedOptionTyped === void 0 ? void 0 : selectedOptionTyped.value);
    }

    return selectedOption && selectedOption.find(option => item.value === option.value);
  };

  return /*#__PURE__*/React.createElement(React.Fragment, null, isOpened && /*#__PURE__*/React.createElement(Portal, {
    hostName: Portals.SelectOutsideWrapper
  }, /*#__PURE__*/React.createElement(TouchableWithoutFeedback, {
    accessibilityLabel: "Close a dropdown from outside",
    accessibilityRole: "button",
    onPress: onOutsidePress
  }, /*#__PURE__*/React.createElement(View, {
    style: styles.modalOverlay
  }))), /*#__PURE__*/React.createElement(Portal, {
    hostName: Portals.Select
  }, /*#__PURE__*/React.createElement(OptionsListWrapper, {
    animated: animated,
    animationDuration: animationDuration,
    isOpened: isOpened,
    wrapperStyles: [styles.options, optionsListStyle, {
      top,
      left,
      width
    }, aboveSelectControl ? styles.overflown : styles.notOverflown]
  }, /*#__PURE__*/React.createElement(FlatList, _extends({
    ref: flatList,
    accessibilityLabel: "Options list",
    accessibilityState: {
      expanded: isOpened
    },
    bounces: false,
    data: resolveData(),
    getItemLayout: (_data, index) => {
      var _StyleSheet$flatten;

      const height = (_StyleSheet$flatten = StyleSheet.flatten(optionStyle)) === null || _StyleSheet$flatten === void 0 ? void 0 : _StyleSheet$flatten.height;
      const isNumber = typeof height === 'number';
      return {
        length: isNumber ? height : ITEM_HEIGHT,
        offset: isNumber ? height * index : ITEM_HEIGHT * index,
        index
      };
    },
    keyExtractor: _ref2 => {
      let {
        value
      } = _ref2;
      return value;
    },
    keyboardShouldPersistTaps: "handled",
    persistentScrollbar: true,
    renderItem: _ref3 => {
      let {
        item,
        index
      } = _ref3;
      const {
        value
      } = item;
      const isSelected = !!resolveIsSelected(item);
      return /*#__PURE__*/React.createElement(Option, {
        key: value,
        ref: index === 0 ? measuredRef : undefined,
        OptionComponent: OptionComponent,
        isSelected: isSelected,
        option: item,
        optionSelectedStyle: optionSelectedStyle,
        optionStyle: optionStyle,
        optionTextStyle: optionTextStyle,
        optionIndex: index,
        onPressOption: onPressOption,
        onSelect: onSelect
      });
    }
  }, flatListProps, {
    ListEmptyComponent: NoOptionsComponent || /*#__PURE__*/React.createElement(NoOptions, {
      noOptionsText: noOptionsText
    })
  })))));
};
const styles = StyleSheet.create({
  modalOverlay: { ...StyleSheet.absoluteFillObject,
    zIndex: 1
  },
  options: {
    flex: 1,
    position: 'absolute',
    zIndex: 1,
    backgroundColor: COLORS.WHITE,
    borderWidth: BORDER_WIDTH,
    maxHeight: MAX_HEIGHT_LIST,
    elevation: 5
  },
  notOverflown: {
    borderTopWidth: 0,
    borderBottomRightRadius: SHAPE,
    borderBottomLeftRadius: SHAPE
  },
  overflown: {
    borderBottomWidth: 0,
    borderTopRightRadius: SHAPE,
    borderTopLeftRadius: SHAPE
  }
});
//# sourceMappingURL=index.js.map